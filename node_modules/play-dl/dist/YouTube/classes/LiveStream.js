"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Stream = exports.LiveEnded = exports.LiveStreaming = void 0;
const stream_1 = require("stream");
const got_1 = __importDefault(require("got"));
const stream_2 = require("../stream");
class LiveStreaming {
    constructor(dash_url, target_interval) {
        this.type = stream_2.StreamType.Arbitrary;
        this.url = dash_url;
        this.base_url = '';
        this.stream = new stream_1.PassThrough({ highWaterMark: 10 * 1000 * 1000 });
        this.segments_urls = [];
        this.packet_count = 0;
        this.request = null;
        this.timer = null;
        this.interval = target_interval * 1000 || 0;
        this.stream.on('close', () => {
            this.cleanup();
        });
        this.start();
    }
    async dash_getter() {
        let response = await got_1.default(this.url);
        let audioFormat = response.body.split('<AdaptationSet id="0"')[1].split('</AdaptationSet>')[0].split('</Representation>');
        if (audioFormat[audioFormat.length - 1] === '')
            audioFormat.pop();
        this.base_url = audioFormat[audioFormat.length - 1].split('<BaseURL>')[1].split('</BaseURL>')[0];
        let list = audioFormat[audioFormat.length - 1].split('<SegmentList>')[1].split('</SegmentList>')[0];
        this.segments_urls = list.replace(new RegExp('<SegmentURL media="', 'g'), '').split('"/>');
        if (this.segments_urls[this.segments_urls.length - 1] === '')
            this.segments_urls.pop();
    }
    cleanup() {
        var _a;
        clearTimeout(this.timer);
        (_a = this.request) === null || _a === void 0 ? void 0 : _a.destroy();
        this.request = null;
        this.timer = null;
        this.url = '';
        this.base_url = '';
        this.segments_urls = [];
        this.packet_count = 0;
        this.interval = 0;
    }
    async start() {
        if (this.stream.destroyed) {
            this.cleanup();
            return;
        }
        await this.dash_getter();
        if (this.packet_count === 0)
            this.packet_count = Number(this.segments_urls[0].split('sq/')[1].split('/')[0]);
        for await (let segment of this.segments_urls) {
            if (Number(segment.split('sq/')[1].split('/')[0]) !== this.packet_count) {
                continue;
            }
            await (async () => {
                return new Promise(async (resolve, reject) => {
                    let stream = got_1.default.stream(this.base_url + segment);
                    this.request = stream;
                    stream.on('data', (chunk) => this.stream.write(chunk));
                    stream.on('end', () => {
                        this.packet_count++;
                        resolve('');
                    });
                    stream.once('error', (err) => {
                        this.stream.emit('error', err);
                    });
                });
            })();
        }
        this.timer = setTimeout(() => {
            this.start();
        }, this.interval);
    }
}
exports.LiveStreaming = LiveStreaming;
class LiveEnded {
    constructor(dash_url) {
        this.type = stream_2.StreamType.Arbitrary;
        this.url = dash_url;
        this.base_url = '';
        this.stream = new stream_1.PassThrough({ highWaterMark: 10 * 1000 * 1000 });
        this.segments_urls = [];
        this.request = null;
        this.packet_count = 0;
        this.stream.on('close', () => {
            this.cleanup();
        });
        this.start();
    }
    async dash_getter() {
        let response = await got_1.default(this.url);
        let audioFormat = response.body.split('<AdaptationSet id="0"')[1].split('</AdaptationSet>')[0].split('</Representation>');
        if (audioFormat[audioFormat.length - 1] === '')
            audioFormat.pop();
        this.base_url = audioFormat[audioFormat.length - 1].split('<BaseURL>')[1].split('</BaseURL>')[0];
        let list = audioFormat[audioFormat.length - 1].split('<SegmentList>')[1].split('</SegmentList>')[0];
        this.segments_urls = list.replace(new RegExp('<SegmentURL media="', 'g'), '').split('"/>');
        if (this.segments_urls[this.segments_urls.length - 1] === '')
            this.segments_urls.pop();
    }
    cleanup() {
        var _a;
        (_a = this.request) === null || _a === void 0 ? void 0 : _a.destroy();
        this.request = null;
        this.url = '';
        this.base_url = '';
        this.segments_urls = [];
        this.packet_count = 0;
    }
    async start() {
        if (this.stream.destroyed) {
            this.cleanup();
            return;
        }
        await this.dash_getter();
        if (this.packet_count === 0)
            this.packet_count = Number(this.segments_urls[0].split('sq/')[1].split('/')[0]);
        for await (let segment of this.segments_urls) {
            if (this.stream.destroyed) {
                this.cleanup();
                break;
            }
            if (Number(segment.split('sq/')[1].split('/')[0]) !== this.packet_count) {
                continue;
            }
            await (async () => {
                return new Promise(async (resolve, reject) => {
                    let stream = got_1.default.stream(this.base_url + segment);
                    this.request = stream;
                    stream.on('data', (chunk) => this.stream.write(chunk));
                    stream.on('end', () => {
                        this.packet_count++;
                        resolve('');
                    });
                    stream.once('error', (err) => {
                        this.stream.emit('error', err);
                    });
                });
            })();
        }
    }
}
exports.LiveEnded = LiveEnded;
class Stream {
    constructor(url, type, duration) {
        this.url = url;
        this.type = type;
        this.stream = new stream_1.PassThrough({ highWaterMark: 10 * 1000 * 1000 });
        this.bytes_count = 0;
        this.per_sec_bytes = 0;
        this.timer = null;
        this.request = null;
        this.stream.on('close', () => {
            this.cleanup();
        });
        this.duration = duration;
        (duration > 300) ? this.loop_start() : this.normal_start();
    }
    cleanup() {
        var _a;
        clearTimeout(this.timer);
        (_a = this.request) === null || _a === void 0 ? void 0 : _a.destroy();
        this.request = null;
        this.timer = null;
        this.url = '';
        this.bytes_count = 0;
        this.per_sec_bytes = 0;
    }
    normal_start() {
        if (this.stream.destroyed) {
            this.cleanup();
            return;
        }
        let stream = got_1.default.stream(this.url);
        this.request = stream;
        stream.once('error', (err) => {
            this.stream.emit('error', err);
        });
        stream.pipe(this.stream);
    }
    loop_start() {
        if (this.stream.destroyed) {
            this.cleanup();
            return;
        }
        let stream = got_1.default.stream(this.url);
        this.request = stream;
        stream.once('data', () => {
            this.per_sec_bytes = Math.ceil(stream.downloadProgress.total / this.duration);
        });
        stream.once('error', (err) => {
            this.stream.emit('error', err);
        });
        stream.on('data', (chunk) => {
            this.bytes_count += chunk.length;
            this.stream.write(chunk);
        });
        stream.on('data', () => {
            if (this.bytes_count > (this.per_sec_bytes * 300)) {
                stream.destroy();
            }
        });
        this.timer = setTimeout(() => {
            this.loop();
        }, 280 * 1000);
    }
    loop() {
        if (this.stream.destroyed) {
            this.cleanup();
            return;
        }
        let absolute_bytes = 0;
        let stream = got_1.default.stream(this.url, {
            headers: {
                "range": `bytes=${this.bytes_count}-`
            }
        });
        this.request = stream;
        stream.on('data', (chunk) => {
            absolute_bytes += chunk.length;
            this.bytes_count += chunk.length;
            this.stream.write(chunk);
        });
        stream.once('error', (err) => {
            this.stream.emit('error', err);
        });
        stream.on('data', () => {
            if (absolute_bytes > (this.per_sec_bytes * 300)) {
                stream.destroy();
            }
        });
        stream.on('end', () => {
            this.cleanup();
        });
        this.timer = setTimeout(() => {
            this.loop();
        }, 280 * 1000);
    }
}
exports.Stream = Stream;
//# sourceMappingURL=LiveStream.js.map